/-----------------------timer impl--------------------------/

extern "C" void SysTick_Handler() {
  BareMetalScheduler::instance().tickISR();
}

// Pseudo-code; adapt to your HAL/SDK
SysTick_Config(SystemCoreClock / 1000);  // fire every 1 ms

/-----------------scheduling memberfunction-----------------/

// In your class header:
class Blinker {
public:
  void toggle() {
    // toggle your LED pin…
  }

  // static wrapper for scheduler
  static void toggleTrampoline(void* ctx) {
    static_cast<Blinker*>(ctx)->toggle();
  }
};

// In your main.cpp:
#include "baremetal_scheduler.hpp"

int main() {
  Blinker blink;
  // Blink every 500 ms
  BareMetalScheduler::instance()
    .scheduleEvery(500,
                   &Blinker::toggleTrampoline,
                   &blink);

  while (1) {
    BareMetalScheduler::instance().dispatch();
    // …other non-interrupt work…
  }
}


/-----------------------One Shot example-------------------/

void hello(void*) {
  // one-time action
}

// schedule hello at tick=2000 (i.e. after 2 s)
BareMetalScheduler::instance().scheduleAt(2000, &hello, nullptr);

/--------------------ticktoucan_platform_stm32.cpp-----------------------/


// ticktoucan_platform_stm32.cpp
#include "ticktoucan_platform.hpp"
#include "stm32f4xx.h"

static void (*s_tickCb)() = nullptr;

uint32_t platform_enter_critical() {
  uint32_t prim = __get_PRIMASK();
  __disable_irq();
  return prim;
}

void platform_exit_critical(uint32_t primask) {
  if ((primask & 1) == 0) __enable_irq();
}

void platform_setup_tick_timer(uint32_t tick_ms,
                               void (*tickCb)())
{
  s_tickCb = tickCb;
  // reload for tick_ms interval
  uint32_t ticks_per_ms = SystemCoreClock / 1000U;
  SysTick_Config(ticks_per_ms * tick_ms - 1U);
}

extern "C" void SysTick_Handler() {
  if (s_tickCb) {
    s_tickCb();
  }
}

